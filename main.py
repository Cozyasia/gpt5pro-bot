# -*- coding: utf-8 -*-
import os
import re
import logging
from typing import List, Tuple

from telegram import Update
from telegram.ext import (
    ApplicationBuilder, CommandHandler, MessageHandler, ContextTypes, filters
)

# -------------------- LOGGING --------------------
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s | %(levelname)s | %(name)s | %(message)s",
)
log = logging.getLogger("gpt-bot")

# -------------------- ENV --------------------
BOT_TOKEN      = os.environ.get("BOT_TOKEN", "").strip()
PUBLIC_URL     = os.environ.get("PUBLIC_URL", "").strip()
OPENAI_API_KEY = os.environ.get("OPENAI_API_KEY", "").strip()
OPENAI_MODEL   = os.environ.get("OPENAI_MODEL", "gpt-4o-mini").strip()  # –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
WEBHOOK_SECRET = os.environ.get("WEBHOOK_SECRET", "").strip()
TAVILY_API_KEY = os.environ.get("TAVILY_API_KEY", "").strip()
BANNER_URL     = os.environ.get("BANNER_URL", "").strip()
PORT           = int(os.environ.get("PORT", "10000"))

if not BOT_TOKEN:
    raise RuntimeError("ENV BOT_TOKEN is required")
if not PUBLIC_URL or not PUBLIC_URL.startswith("http"):
    raise RuntimeError("ENV PUBLIC_URL must look like https://xxx.onrender.com")

# -------------------- TEXTS --------------------
START_GREETING = (
    "–ü—Ä–∏–≤–µ—Ç! –Ø –≥–æ—Ç–æ–≤. –ù–∞–ø–∏—à–∏ –ª—é–±–æ–π –≤–æ–ø—Ä–æ—Å.\n\n"
    "–ü–æ–¥—Å–∫–∞–∑–∫–∏:\n"
    "‚Ä¢ –Ø –æ—Ç–≤–µ—á–∞—é —Å–∞–º, –∞ –µ—Å–ª–∏ –Ω—É–∂–Ω–æ ‚Äî —Å–≤–µ—Ä—è—é—Å—å —Å –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–æ–º –∏ –¥–∞—é —Å—Å—ã–ª–∫–∏.\n"
    "‚Ä¢ –ú–æ–≥—É –∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å —Ñ–æ—Ç–æ/–∫–∞—Ä—Ç–∏–Ω–∫–∏ (—á–µ—Ä–µ–∑ üìé) ‚Äî –ø—Ä–æ—á–∏—Ç–∞—Ç—å —Ç–µ–∫—Å—Ç, –æ–ø–∏—Å–∞—Ç—å –æ–±—ä–µ–∫—Ç—ã, —Å–¥–µ–ª–∞—Ç—å –≤—ã–≤–æ–¥—ã.\n"
    "‚Ä¢ –ü—Ä–∏–º–µ—Ä—ã: ¬´–î–∞—Ç–∞ –≤—ã—Ö–æ–¥–∞ GTA 6?¬ª, ¬´–ö—É—Ä—Å –±–∏—Ç–∫–æ–∏–Ω–∞ —Å–µ–π—á–∞—Å –∏ –ø—Ä–æ–≥–Ω–æ–∑¬ª, "
    "¬´–ù–∞–π–¥–∏ —É—á–µ–±–Ω–∏–∫ –∞–ª–≥–µ–±—Ä—ã 11 –∫–ª–∞—Å—Å (–æ—Ñ–∏—Ü–∏–∞–ª—å–Ω—ã–µ –∏—Å—Ç–æ—á–Ω–∏–∫–∏)¬ª, ¬´–ö—Ç–æ —Ç–∞–∫–æ–π ‚Ä¶?¬ª –∏ —Ç.–¥."
)

# -------------------- HEURISTICS --------------------
_greetings = re.compile(r"\b(–ø—Ä–∏–≤(–µ—Ç|—Å—Ç–≤—É—é)|–∑–¥—Ä–∞–≤—Å—Ç–≤|–¥–æ–±—Ä–æ–µ|–¥–æ–±—Ä—ã–π|hello|hi|hey)\b", re.I)
_smalltalk = re.compile(r"(–∫–∞–∫ –¥–µ–ª–∞|–∫—Ç–æ —Ç—ã|—á—Ç–æ —É–º–µ–µ—à—å|—Å–ø–∞—Å–∏–±–æ|–±–ª–∞–≥–æ–¥–∞—Ä—é|–ø–æ–∫–∞|–¥–æ —Å–≤–∏–¥|—Ä–∞–¥ –∑–Ω–∞–∫–æ–º—Å—Ç–≤—É)", re.I)
_no_web_hint = re.compile(r"(–±–µ–∑ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–∞|–Ω–µ –∏—â–∏|–Ω–µ –≥—É–≥–ª–∏)", re.I)

_need_web_keywords = [
    "—Å–µ–≥–æ–¥–Ω—è", "—Å–µ–π—á–∞—Å", "–∑–∞–≤—Ç—Ä–∞", "–Ω–æ–≤–æ—Å—Ç", "–æ–±–Ω–æ–≤–ª–µ–Ω", "—Ä–µ–ª–∏–∑", "–∫–æ–≥–¥–∞", "–¥–∞—Ç–∞",
    "–∫—É—Ä—Å", "–∫–æ—Ç–∏—Ä–æ–≤", "—Ü–µ–Ω–∞", "—Å—Ç–æ–∏–º–æ—Å—Ç—å", "—Å—Ç–∞–≤–∫–∞", "–∏–Ω–¥–µ–∫—Å", "–∞–∫—Ü–∏", "–±–∏—Ç–∫–æ–∏–Ω", "btc",
    "–ø–æ–≥–æ–¥–∞", "—Ä–∞—Å–ø–∏—Å–∞–Ω", "—Ç—Ä–∞–Ω—Å–ª—è—Ü", "–º–∞—Ç—á", "—Ç—É—Ä–Ω–∏—Ä", "—Ä–µ–π—Å", "—Å–∞–º–æ–ª–µ—Ç", "–ø–æ–µ–∑–¥",
    "–Ω–∞–π–¥–∏", "—Å—Å—ã–ª–∫–∞", "—Å—Å—ã–ª–∫–∏", "–æ—Ñ–∏—Ü–∏–∞–ª—å–Ω", "–≤–∏–∫–∏–ø–µ–¥", "pdf", "—Å–∫–∞—á–∞—Ç—å", "–¥–æ–∫—É–º–µ–Ω—Ç",
    "—É—á–µ–±–Ω–∏–∫", "–º–∞–Ω—É–∞–ª", "—Ä—É–∫–æ–≤–æ–¥—Å—Ç–≤", "–∞–¥—Ä–µ—Å", "—Ç–µ–ª–µ—Ñ–æ–Ω", "–∫–æ–Ω—Ç–∞–∫—Ç—ã", "–∫–∞–∫ –¥–æ–±—Ä–∞—Ç—å—Å—è",
]

def need_web_search(text: str) -> bool:
    t = text.strip().lower()
    if _no_web_hint.search(t):
        return False
    if len(t) <= 2 or _greetings.search(t) or _smalltalk.search(t):
        return False
    for kw in _need_web_keywords:
        if kw in t:
            return True
    if re.search(r"\b(—á—Ç–æ|–∫—Ç–æ|–≥–¥–µ|–∫–æ–≥–¥–∞|–ø–æ—á–µ–º—É|–∑–∞—á–µ–º|–∫–∞–∫–æ–π|–∫–∞–∫–∏–µ|—Å–∫–æ–ª—å–∫–æ|–∫–∞–∫)\b", t) and "–ø—Ä–∏–º–µ—Ä" not in t:
        if any(x in t for x in ["–ø–µ—Ä–µ–≤–µ–¥–∏", "–ø–µ—Ä–µ–≤–æ–¥", "–ø–µ—Ä–µ–ø–∏—à–∏", "—Å—Ñ–æ—Ä–º—É–ª–∏—Ä—É–π", "–ø—Ä–∏–¥—É–º–∞–π", "–Ω–∞–ø–∏—Å–∞—Ç—å", "–Ω–∞–ø–æ–ª–Ω–∏"]):
            return False
        return True
    return len(t) >= 160

# -------------------- LLM & SEARCH --------------------
from openai import OpenAI
client = OpenAI(api_key=OPENAI_API_KEY) if OPENAI_API_KEY else None

def llm_answer(user_text: str, system_hint: str = "") -> str:
    sp = (
        "–¢—ã –¥—Ä—É–∂–µ–ª—é–±–Ω—ã–π –∏ –ª–∞–∫–æ–Ω–∏—á–Ω—ã–π –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç. –û—Ç–≤–µ—á–∞–π –ø–æ –¥–µ–ª—É, "
        "–Ω–µ –≤—ã–¥—É–º—ã–≤–∞–π —Ñ–∞–∫—Ç–æ–≤. –ï—Å–ª–∏ –Ω–µ —Ö–≤–∞—Ç–∞–µ—Ç –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ ‚Äî –ø—Ä–µ–¥–ª–æ–∂–∏ —É—Ç–æ—á–Ω–∏—Ç—å."
    )
    if system_hint:
        sp += " " + system_hint
    try:
        resp = client.chat.completions.create(
            model=OPENAI_MODEL,
            messages=[
                {"role": "system", "content": sp},
                {"role": "user", "content": user_text},
            ],
            temperature=0.6,
        )
        return (resp.choices[0].message.content or "").strip()
    except Exception as e:
        log.exception("OpenAI error: %s", e)
        return "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –æ—Ç–≤–µ—Ç –æ—Ç –º–æ–¥–µ–ª–∏. –ü–æ–ø—Ä–æ–±—É–π –µ—â—ë —Ä–∞–∑ –ø–æ–∑–∂–µ."

def web_search(query: str) -> Tuple[str, List[Tuple[str, str]]]:
    try:
        from tavily import TavilyClient
        tv = TavilyClient(api_key=TAVILY_API_KEY)
        res = tv.search(
            query=query, search_depth="advanced",
            max_results=6, include_answer=True,
        )
        answer = (res.get("answer") or "").strip()
        sources = []
        for item in res.get("results", []):
            title = (item.get("title") or "–ò—Å—Ç–æ—á–Ω–∏–∫").strip()
            url = (item.get("url") or "").strip()
            if url:
                sources.append((title, url))
        return answer, sources
    except Exception as e:
        log.exception("Tavily error: %s", e)
        return "", []

def synthesize_with_sources(user_text: str, web_answer: str, sources: List[Tuple[str, str]]) -> str:
    context = (
        "–ò—Å–ø–æ–ª—å–∑—É–π —Å–≤–æ–¥–∫—É –∏–∑ –ø–æ–∏—Å–∫–∞ –∏ –æ—Ñ–æ—Ä–º–∏ —è—Å–Ω—ã–π –æ—Ç–≤–µ—Ç –Ω–∞ —Ä—É—Å—Å–∫–æ–º. "
        "–ï—Å–ª–∏ –≤ —Å–≤–æ–¥–∫–µ –Ω–µ—Ç —Ç–æ—á–Ω–æ–≥–æ —Ñ–∞–∫—Ç–∞ ‚Äî —Å–∫–∞–∂–∏ –æ–± —ç—Ç–æ–º. "
        "–ù–µ –ø–∏—à–∏ –æ–≥—Ä–æ–º–Ω—ã–π —Ä–µ—Ñ–µ—Ä–∞—Ç ‚Äî 3‚Äì7 –∫–æ—Ä–æ—Ç–∫–∏—Ö –∞–±–∑–∞—Ü–µ–≤ –∏–ª–∏ —Å–ø–∏—Å–æ–∫. "
        "–í –∫–æ–Ω—Ü–µ –ø–µ—Ä–µ—á–∏—Å–ª–∏ –∏—Å—Ç–æ—á–Ω–∏–∫–∏ —Å–ø–∏—Å–∫–æ–º."
    )
    combined_prompt = (
        f"–í–æ–ø—Ä–æ—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {user_text}\n\n"
        f"–°–≤–æ–¥–∫–∞ –∏–∑ –ø–æ–∏—Å–∫–∞:\n{web_answer or '‚Äî'}\n"
        f"(–ü–æ–¥—Ä–æ–±–Ω—ã–µ —Å—Å—ã–ª–∫–∏ –¥–æ–±–∞–≤–∏—Ç –±–æ—Ç.)"
    )
    body = llm_answer(combined_prompt, system_hint=context)
    if sources:
        links = "\n".join([f"‚Ä¢ {title} ‚Äî {url}" for title, url in sources[:6]])
        body = f"{body}\n\n–°—Å—ã–ª–∫–∏:\n{links}"
    return body

# ---------- Helpers –¥–ª—è –∑–∞–≥—Ä—É–∑–æ–∫ –∏–∑ Telegram ----------
async def _tg_file_url(context: ContextTypes.DEFAULT_TYPE, file_id: str) -> str:
    """
    –ü–æ–ª—É—á–∞–µ–º –ø—Ä—è–º—É—é —Å—Å—ã–ª–∫—É –Ω–∞ —Ñ–∞–π–ª Telegram (—Å —Ç–æ–∫–µ–Ω–æ–º –±–æ—Ç–∞).
    OpenAI —Å–º–æ–∂–µ—Ç –µ—ë —Å–∫–∞—á–∞—Ç—å, —á—Ç–æ–±—ã –ø—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.
    """
    f = await context.bot.get_file(file_id)
    return f"https://api.telegram.org/file/bot{BOT_TOKEN}/{f.file_path}"

def vision_on_image(image_url: str, user_hint: str = "") -> str:
    """
    –ê–Ω–∞–ª–∏–∑ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è —á–µ—Ä–µ–∑ –º–æ–¥–µ–ª—å —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π vision.
    """
    try:
        sys = (
            "–¢—ã –∫–æ–º–ø—å—é—Ç–µ—Ä–Ω–æ–µ –∑—Ä–µ–Ω–∏–µ-–∞—Å—Å–∏—Å—Ç–µ–Ω—Ç. –û–ø–∏—Å—ã–≤–∞–π –∫—Ä–∞—Ç–∫–æ –∏ —Ç–æ—á–Ω–æ, "
            "–∏–∑–≤–ª–µ–∫–∞–π –∫–ª—é—á–µ–≤—ã–µ —Ñ–∞–∫—Ç—ã, –ø–µ—Ä–µ—á–∏—Å–ª—è–π –æ–±—ä–µ–∫—Ç—ã, –ø–æ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ —Å—á–∏—Ç—ã–≤–∞–π —Ç–µ–∫—Å—Ç (OCR) "
            "–∏ –¥–µ–ª–∞–π –≤—ã–≤–æ–¥—ã, –ø–æ–ª–µ–∑–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é."
        )
        user_text = user_hint.strip() or "–ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ. –ò–∑–≤–ª–µ–∫–∏ —Ç–µ–∫—Å—Ç, –ø–µ—Ä–µ—á–∏—Å–ª–∏ –≤–∞–∂–Ω—ã–µ –æ–±—ä–µ–∫—Ç—ã –∏ —Å–¥–µ–ª–∞–π –≤—ã–≤–æ–¥—ã."
        resp = client.chat.completions.create(
            model=OPENAI_MODEL,
            messages=[
                {"role": "system", "content": sys},
                {"role": "user", "content": [
                    {"type": "text", "text": user_text},
                    {"type": "image_url", "image_url": {"url": image_url}},
                ]},
            ],
            temperature=0.2,
        )
        return (resp.choices[0].message.content or "").strip()
    except Exception as e:
        log.exception("Vision error: %s", e)
        return "–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ. –ü–æ–ø—Ä–æ–±—É–π –µ—â—ë —Ä–∞–∑ –∏–ª–∏ –ø—Ä–∏—à–ª–∏ –¥—Ä—É–≥–æ–π —Ñ–∞–π–ª."

# -------------------- HANDLERS --------------------
async def cmd_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if BANNER_URL:
        try:
            await update.effective_message.reply_photo(BANNER_URL)
        except Exception:
            pass
    await update.effective_message.reply_text(START_GREETING, disable_web_page_preview=True)

async def on_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = (update.message.text or "").strip()
    if not OPENAI_API_KEY:
        await update.message.reply_text("OPENAI_API_KEY –Ω–µ –∑–∞–¥–∞–Ω. –°–æ–æ–±—â–∏ –∞–¥–º–∏–Ω—É.")
        return

    use_web = bool(TAVILY_API_KEY) and need_web_search(text)
    if not use_web:
        answer = llm_answer(text)
        await update.message.reply_text(answer, disable_web_page_preview=True)
        return

    web_answer, sources = web_search(text)
    if not web_answer and not sources:
        fallback = llm_answer(
            f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å–ø—Ä–æ—Å–∏–ª: {text}\n"
            f"–ü–æ–∏—Å–∫ –≤ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–µ –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ –¥–∞–ª —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤. "
            f"–î–∞–π –æ–±—â–∏–π –æ—Ç–≤–µ—Ç –∏ –ø—Ä–µ–¥–ª–æ–∂–∏ —É—Ç–æ—á–Ω–∏—Ç—å –∫—Ä–∏—Ç–µ—Ä–∏–∏/–∏—Å—Ç–æ—á–Ω–∏–∫–∏."
        )
        await update.message.reply_text(fallback, disable_web_page_preview=True)
        return

    final = synthesize_with_sources(text, web_answer, sources)
    await update.message.reply_text(final, disable_web_page_preview=True)

# ---- –§–æ—Ç–æ –∏ –∫–∞—Ä—Ç–∏–Ω–∫–∏ (–≤–∫–ª—é—á–∞—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–µ ¬´–∫–∞–∫ —Ñ–∞–π–ª¬ª) ----
async def on_image(update: Update, context: ContextTypes.DEFAULT_TYPE):
    msg = update.message
    caption = (msg.caption or "").strip()

    file_id = None
    if msg.photo:
        # –±–µ—Ä—ë–º —Å–∞–º–æ–µ –±–æ–ª—å—à–æ–µ –ø—Ä–µ–≤—å—é
        file_id = msg.photo[-1].file_id
    elif msg.document and (msg.document.mime_type or "").startswith("image/"):
        file_id = msg.document.file_id

    if not file_id:
        await msg.reply_text("–§–∞–π–ª –Ω–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω –∫–∞–∫ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.")
        return

    if not OPENAI_API_KEY:
        await msg.reply_text("OPENAI_API_KEY –Ω–µ –∑–∞–¥–∞–Ω. –°–æ–æ–±—â–∏ –∞–¥–º–∏–Ω—É.")
        return

    try:
        url = await _tg_file_url(context, file_id)
        result = vision_on_image(url, user_hint=caption)
        await msg.reply_text(result, disable_web_page_preview=True)
    except Exception as e:
        log.exception("on_image error: %s", e)
        await msg.reply_text("–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ. –ü–æ–ø—Ä–æ–±—É–π –µ—â—ë —Ä–∞–∑.")

# ---- –í–∏–¥–µ–æ: —Ä–∞–∑–±–∏—Ä–∞–µ–º –ø—Ä–µ–≤—å—é-–∫–∞–¥—Ä (thumbnail) ----
async def on_video(update: Update, context: ContextTypes.DEFAULT_TYPE):
    msg = update.message
    v = msg.video
    thumb = getattr(v, "thumbnail", None) or getattr(v, "thumb", None)

    if not thumb:
        await msg.reply_text(
            "–Ø –ø–æ–ª—É—á–∏–ª –≤–∏–¥–µ–æ. –°–µ–π—á–∞—Å –º–æ–≥—É –∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –µ–≥–æ –ø—Ä–µ–≤—å—é-–∫–∞–¥—Ä. "
            "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø—Ä–∏—à–ª–∏ —Å–∫—Ä–∏–Ω—à–æ—Ç—ã –∫–ª—é—á–µ–≤—ã—Ö –º–æ–º–µ–Ω—Ç–æ–≤ ‚Äî –¥–∞–º –ø–æ–¥—Ä–æ–±–Ω—ã–π —Ä–∞–∑–±–æ—Ä."
        )
        return

    if not OPENAI_API_KEY:
        await msg.reply_text("OPENAI_API_KEY –Ω–µ –∑–∞–¥–∞–Ω. –°–æ–æ–±—â–∏ –∞–¥–º–∏–Ω—É.")
        return

    try:
        url = await _tg_file_url(context, thumb.file_id)
        hint = (msg.caption or "").strip()
        hint = ("–≠—Ç–æ –ø—Ä–µ–≤—å—é –∫–∞–¥—Ä –≤–∏–¥–µ–æ. –û–ø–∏—à–∏, —á—Ç–æ –≤–∏–¥–Ω–æ, —Å—á–∏—Ç–∞–π —Ç–µ–∫—Å—Ç, "
                "–≤—ã–¥–µ–ª–∏ –∫–ª—é—á–µ–≤—ã–µ –æ–±—ä–µ–∫—Ç—ã –∏ —Å–¥–µ–ª–∞–π –≤—ã–≤–æ–¥—ã. " + (hint if hint else ""))
        result = vision_on_image(url, user_hint=hint)
        await msg.reply_text(result, disable_web_page_preview=True)
    except Exception as e:
        log.exception("on_video error: %s", e)
        await msg.reply_text("–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –ø—Ä–µ–≤—å—é –≤–∏–¥–µ–æ. –ü—Ä–∏—à–ª–∏ —Å–∫—Ä–∏–Ω—à–æ—Ç—ã ‚Äî —Ä–∞–∑–±–µ—Ä—É –∏—Ö.")

# -------------------- BOOTSTRAP --------------------
def build_app():
    app = ApplicationBuilder().token(BOT_TOKEN).build()
    app.add_handler(CommandHandler("start", cmd_start))

    # –º–µ–¥–∏–∞
    app.add_handler(MessageHandler(filters.PHOTO | filters.Document.IMAGE, on_image))
    app.add_handler(MessageHandler(filters.VIDEO, on_video))

    # —Ç–µ–∫—Å—Ç
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, on_text))
    return app

def run_webhook(app):
    url_path = f"webhook/{BOT_TOKEN}"
    webhook_url = f"{PUBLIC_URL.rstrip('/')}/{url_path}"

    log.info("Starting webhook on 0.0.0.0:%s  ->  %s", PORT, webhook_url)
    app.run_webhook(
        listen="0.0.0.0",
        port=PORT,
        url_path=url_path,
        webhook_url=webhook_url,
        secret_token=WEBHOOK_SECRET or None,
        drop_pending_updates=True,
    )

def main():
    app = build_app()
    run_webhook(app)

if __name__ == "__main__":
    main()
